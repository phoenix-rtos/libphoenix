Operations Manual
=================

Set-up and Initialization
~~~~~~~~~~~~~~~~~~~~~~~~~

In short:

* call ``configure``
* call ``make``

The first step to include the mathematical library into another software project is to build the static library from the library source code. For this procedure, a configuration script and a Makefile are prepared.

First the user has to run the configuration script which will interactively ask for several configuration items. To reduce the number of questions asked interactively the ``configure`` script can be called with flags. During configuration you will be asked ...

* ... for the path to the compilation toolchain. (Flag: ``--cross-compile <CROSS_COMPILE>``)
* ... for additional compilation flags. (Flag: ``--compilation-flags <CFLAGS>``)
* ... whether the platform does not support subnormals and as such uses a non-standard :ref:`FTZ/DAZ <ABBR>` mode. (Flag: ``--enable-denormal-handling`` or ``--disable-denormal-handling``)
* ... whether you want ``long double`` procedures (this will only be asked if the toolchain informs the configuration script that ``long double`` are 64 bit in size). (Flag: ``--enable-long-double-procedures`` or ``--disable-long-double-procedures``)
* ... for your platforms endianess (this will only be asked if the toolchain does not provide the answer). (Flag: ``--big-endian`` or ``--little-endian``)
* ... whether you want complex procedures. (Flag: ``--enable-complex-procedures`` or ``--disable-complex-procedures``)

The configuration creates a secondary Makefile ``user_make.mk``, which will then be used by the primary Makefile. As such it should not be moved elsewhere (if it is not where it should be the primary Makefile will assume ``configure`` has not been executed and display an error). It contains flags and variables based on the choices made during ``configure`` as well as an additional variable which tells the primary Makefile that the configuration was properly finished.

The Makefile provides the following targets:

* ``all``: Compiles and builds the library.
* ``debug``: Compiles and builds the library. Same as ``all``.
* ``release``: Compiles and builds the library. Add the compilation flag ``-DNDEBUG``, afterwards runs ``all``.
* ``clean``: Removes the object files and the static library of the chosen build.
* ``cleanall``: Removes the object files and static libraries from all builds.
* ``distclean``: Removes files generated by the configuration script.
* ``install``: The library does not need to be installed. As such running ``install`` only yields an information message.

The targets ``all``, ``debug``, ``release``, and ``clean`` can be modified using the following constants:

* ``CROSS_COMPILE``: Prefix to tell the Makefile which compiler to use. This is usually already set during configuration.
* ``ARCH``: Tells the Makefile for which architecture the build is intended. If not provided this defaults to a target stated by the :ref:`GCC <ABBR>` provided via ``CROSS_COMPILE``.
* ``COVERAGE=true``: Tells the Makefile to use flags specific to the generation of coverage reports.

.. note::
   The library has been built to compile without warnings but the compilation process might show some warnings about the use of potentially
   uninitialized variables depending on the compiler version (and or specific compiler flags). These warnings can be
   disregarded as all variable uses have been statically analyzed and shown to be correct
   in all cases.

The resulting libraries can be found in the ``build-ARCH/bin`` directory, with ``ARCH`` being the provided constant, or if not provided defaults to the target defined by :ref:`GCC <ABBR>` (this can be inspected with the shell command ``gcc -v``). The intermediate object files can be found in the ``build-ARCH/obj`` directory.

After finishing the build `make` will also create a build info file within the ``build-ARCH`` directory. This file is aptly named ``build_info.yml`` and contains the following information in :ref:`YAML <ABBR>` format:

* timestamp on when the build was made,
* path to the compiler, information provided by the compiler (such as version), compilation flags, includes,
* git information: branch name, commit hash, check if the commit is clean or if changes were made (dirty),
* sha256 of the generated libm.a

Both of the files ``build_info.yml`` and ``user_make.mk`` provide information to MAXI while creating the final reports, as such they need to stay at the path they were generated at. The same applies to the ``libm.a`` itself.

Getting Started
~~~~~~~~~~~~~~~

In the last section, the code of the mathematical library is prepared in a static library. To use the library, the library header files have to be included in the user's source code. The useable header files are ``math.h``, and ``complex.h``. The complex procedures however will only exist if they were chosen to during configuration.

Mode Selection and Control
~~~~~~~~~~~~~~~~~~~~~~~~~~

After writing the project specific code, the last step to build a program which includes the library is to compile the new software. During the compilation two steps are necessary for success:

#. Link to the static library (``libm.a``).
#. Include the header files located in ``libm/include``

As an example by using :ref:`GCC <ABBR>` the following line should work::

   $ gcc -o new_executable_software new_software_source_code.c libmcs/build-x86_64-linux-gnu/bin/libm.a -Ilibmcs/libm/include

The user has to add a number of additional flags, beginning with those listed in :ref:`OperationsEnviromentSoftwareConfiguration`. One might also need a number of platform or hardware specific flags, e.g. the flag ``-qleon2`` when building for the Leon2 platform with Gaisler's :ref:`RTEMS <ABBR>`. Extra flags depend on the :ref:`OS <ABBR>`, the compilation toolchain, and possibly a :ref:`BSP <ABBR>`; please check the corresponding documentation for your situation. It is suggested to write a Makefile for this (or use tools for the creation of Makefiles).

Normal Operations
~~~~~~~~~~~~~~~~~

All accessible procedures within the library are shown in chapter :ref:`Purpose of the Software`. For detailed information on each procedure, take a look at the related subsection in :ref:`Reference Manual`.

Normal Termination
~~~~~~~~~~~~~~~~~~

Each procedure in the library is executed when called and computes a result. There is no software interruption foreseen during the computation and the procedure terminates by returning the result. If there is an interrupt, e.g. a context switch caused by the underlying operating system, the correct re-schedule has to be managed by the causing operating system.

.. _OperationsManualErrorConditions:

Error Conditions
~~~~~~~~~~~~~~~~

There is no error condition handling in the library. The ``errno`` variable proposed by the :ref:`ISO <ABBR>` C standard is not set by the library. Error states may only be caused by the used hardware and must be handled by the user's software. For example the following errors may occur:

* Any :ref:`FPU <ABBR>` can produce traps depending on its configuration. See :ref:`OperationsEnviromentHardwareConfiguration` for more information.
* The program stack can overflow if the stack size limit is exceeded by calling one of the provided procedures, even though their memory footprint is rather low.
